package aerygen

import (
	"fmt"
	"log"
	"strings"

	"cuelang.org/go/cue"
	"github.com/azure/azure-dev/cli/azd/resources"
	"github.com/braydonk/yaml"
)

// Azure naming conventions.
type AzureNames struct {
	// Conventions groupe by resource types, with their associated kinds.
	Types map[string][]ResourceKind `yaml:"resourceTypes"`
}

// A resource kind. A resource type can have multiple kinds.
// In the default case, a resource type has a single kind that is empty.
type ResourceKind struct {
	// Display name of the resource kind.
	Name string `yaml:"name"`
	// The kind of the resource. Empty for resources with just types but no kinds.
	Kind string `yaml:"kind,omitempty"`
	// A custom kind. The value that determines the kind is embedded somewhere as a property in the resource JSON.
	CustomKind CustomKind `yaml:"customKind,omitempty"`
	// Short name abbreviation for new resources.
	Abbreviation string `yaml:"abbreviation"`
	// The rules for naming a resource.
	NamingRules NamingRules `yaml:"namingRules,omitempty"`
}

// The rules for naming a resource.
type NamingRules struct {
	MinLength       int    `yaml:"minLength,omitempty"`
	MaxLength       int    `yaml:"maxLength,omitempty"`
	UniquenessScope string `yaml:"uniquenessScope"`
	Regex           string `yaml:"regex"`
	WordSeparator   string `yaml:"wordSeparator"`

	RestrictedChars RestrictedChars `yaml:"restrictedChars,omitempty"`
	Messages        Messages        `yaml:"messages,omitempty"`
}

type CustomKind struct {
	PropertyPath string `yaml:"propertyPath,omitempty"`
	Value        string `yaml:"value,omitempty"`
}

type Messages struct {
	OnSuccess string `yaml:"onSuccess,omitempty"`
	OnFailure string `yaml:"onFailure,omitempty"`
}

type RestrictedChars struct {
	Global      string `yaml:"global,omitempty"`
	Prefix      string `yaml:"prefix,omitempty"`
	Suffix      string `yaml:"suffix,omitempty"`
	Consecutive string `yaml:"consecutive,omitempty"`
}

var names AzureNames

func init() {
	err := yaml.Unmarshal(resources.AzureNames, &names)
	if err != nil {
		log.Panic("failed marshaling azure resource names %w", err)
	}
}

var ErrNotFound = fmt.Errorf("naming translation for resource type not found")

// Name returns the a suitable name for the given resource.
//
// The name is currently generated by:
//   - {abbreviation}[-]{token}
//
// Where the token is generated derived from {subId, group, location}.
// If the resource type/kind restricts the use of "-", "-" is omitted from the name.
func Name(
	token string,
	// subId string,
	// group string,
	// location string,
	resourceDefinition cue.Value) (string, error) {
	existingName := resourceDefinition.LookupPath(cue.ParsePath("name"))
	if val, err := existingName.String(); err == nil {
		return val, nil
	}

	resourceType, err := resourceDefinition.LookupPath(cue.ParsePath("type")).String()
	if err != nil {
		return "", fmt.Errorf("error getting resource.type: %w", err)
	}

	resTypeNames, ok := names.Types[resourceType]
	if !ok {
		return "", fmt.Errorf("%s: %w", resourceType, ErrNotFound)
	}

	// fallback for the resource type abbreviation
	kind, err := matchResourceKind(resourceDefinition, resTypeNames)
	if err != nil {
		return "", fmt.Errorf("error getting resource kind: %w", err)
	}

	if kind == nil {
		return "", fmt.Errorf("evaluating kind: %s: %w", resourceType, ErrNotFound)
	}

	// token, err := aery.UniqueString(subId, group, location)
	// if err != nil {
	// 	return "", fmt.Errorf("error generating resource token: %w", err)
	// }

	separator := "-"
	if strings.Contains(kind.NamingRules.RestrictedChars.Global, "-") {
		separator = ""
	}

	return fmt.Sprintf("%s%s%s",
		kind.Abbreviation,
		separator,
		token), nil
}

// matchResourceKind returns the kind of the resource definition.
func matchResourceKind(
	resourceDefinition cue.Value,
	kinds []ResourceKind) (*ResourceKind, error) {
	var foundKind *ResourceKind

	for _, resKind := range kinds {
		if resKind.Kind == "" {
			foundKind = &resKind
			continue
		}

		// evaluate the kind rule to see if applies
		kindPath := "kind"
		kindVal := resKind.Kind
		if resKind.CustomKind.PropertyPath != "" {
			kindPath = resKind.CustomKind.PropertyPath
			kindVal = resKind.CustomKind.Value
		}

		lookupKind := resourceDefinition.LookupPath(cue.ParsePath(
			fmt.Sprintf("spec.%s", kindPath)))
		if lookupKind.Exists() {
			resourceDefKind, err := lookupKind.String()
			if err != nil {
				return nil, fmt.Errorf("error getting resource.%s: %w", kindPath, err)
			}

			// case-insensitive, partial match
			if strings.Contains(strings.ToLower(resourceDefKind), strings.ToLower(kindVal)) {
				foundKind = &resKind
				break
			}
		}
	}

	return foundKind, nil
}
