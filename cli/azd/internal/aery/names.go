package aery

import (
	"errors"
	"fmt"
	"strings"

	"github.com/azure/azure-dev/cli/azd/pkg/azure"
)

var ErrNotFound = fmt.Errorf("naming translation for resource type not found")

// Name returns the a suitable name for the given resource.
//
// The name is currently generated by:
//   - {alias}[-]{token}
//
// Where the token is generated derived from {subId, group, location}.
// If the resource type/kind restricts the use of "-", "-" is omitted from the name.
func Name(token string, spec ResourceSpec) (string, error) {
	if spec.Name != "" {
		return spec.Name, nil
	}

	if spec.Alias == "" {
		return "", fmt.Errorf("alias is required for determining name")
	}

	resTypeNames, ok := azure.Names.Types[spec.Type]
	if !ok {
		return "", fmt.Errorf("%s: %w", spec.Type, ErrNotFound)
	}

	// fallback for the resource type abbreviation
	kind, err := matchResourceKind(spec, resTypeNames)
	if err != nil {
		return "", fmt.Errorf("error getting resource kind: %w", err)
	}

	if kind == nil {
		return "", fmt.Errorf("evaluating kind: %s: %w", spec.Type, ErrNotFound)
	}

	separator := "-"
	if strings.Contains(kind.NamingRules.RestrictedChars.Global, "-") {
		separator = ""
	}

	return fmt.Sprintf("%s%s%s",
		spec.Alias,
		separator,
		token), nil
}

// matchResourceKind returns the kind of the resource definition.
func matchResourceKind(
	spec ResourceSpec,
	kinds []azure.ResourceKind) (*azure.ResourceKind, error) {
	var foundKind *azure.ResourceKind

	for _, resKind := range kinds {
		if resKind.Kind == "" {
			foundKind = &resKind
			continue
		}

		// evaluate the kind rule to see if applies
		kindPath := "kind"
		kindVal := resKind.Kind
		if resKind.CustomKind.PropertyPath != "" {
			kindPath = resKind.CustomKind.PropertyPath
			kindVal = resKind.CustomKind.Value
		}

		lookupKind, err := GetNode(&spec.Spec, fmt.Sprintf("spec.%s", kindPath))
		if !errors.Is(err, ErrNodeNotFound) && err != nil {
			return nil, fmt.Errorf("evaluating kind for resource '%s': %w", spec.Type, err)
		}

		if err == nil {
			// case-insensitive, partial match
			if strings.Contains(strings.ToLower(lookupKind.Value), strings.ToLower(kindVal)) {
				foundKind = &resKind
				break
			}
		}
	}

	return foundKind, nil
}
